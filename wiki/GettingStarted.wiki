#summary Getting started with CoreDataLibrary

= Introduction =

This guide walks you through the basic steps necessary to create an application with the CoreDataLibrary.  It assumes familiarity with Core Data, iPhone programming and XCode.

== Prerequisites == 

 * Ensure the CoreDataLibrary template is installed (see the [Installation installation guide]).
 * This is untested on anything lower than iPhone OS 3.1.3 and XCode 3.2.1

== Creating the project and updating the Core Data Model ==

 # Create a new XCode project using the `CoreDataLibrary Application` template.  We called our project `GettingStarted.`
   * http://imgur.com/2gSBN.png
 # By default, the template includes an entity named `Event` with two attributes, `name` and `timeStamp.`  The CDLRootViewController is configured to not have sections or section index titles.  If you make no changes to the project and run in the simulator, you will see a screen similar to below.
   * http://imgur.com/IzfGX.png
 # In this guide, we will add several attributes (a string called `detail` and a boolean called `publicEvent`and to-one relationship called `type`).  To begin, open the `GettingStarted.xcdatamodel` file under Resources.
 # You will be presented with the Core Data model editor.  Configure the model as shown below (click image for a bigger version)
  * [http://imgur.com/nvZXd.png http://imgur.com/nvZXdl.jpg]
 # Remove the `Event.h` and `Event.m` files from the project.
 # Select the `Event` and `EventType` entities in the Core Data model and select File -> *New File*.
  * http://imgur.com/KBTrH.png
 # From the New File dialog, select *Cocoa Touch Class* from beneath iPhone OS.  Then, select *Managed Object Class* from the list of choices.
  * http://imgur.com/rHPNK.png
 # Complete the New File wizard, accepting all defaults.  You will now have 4 new files, `Event.[m|h]` and `EventType.[m|h]`.

== Updating the DetailView property list ==

 # We will now update the DetailView to include the new attributes and relationship.  Open the `GettingStartedDetailView.plist` file.
  * We are going add the `publicEvent` and `type` properties to the existing section and create a new section for the `detail` property.
 # Create two new members of type Dictionary in the existing rowInformation array. Configure them as the screenshot below.  This is for the `publicEvent` and `type` properties. 
  * http://imgur.com/xbocM.png
 # Now, create a new Dictionary in the root array and configure it as the screenshot below.  This is for the `detail` property.
  * http://imgur.com/xIkD9.png

== Creating a custom row ==

 # We will now create a custom row to present a Delete button within the detail view (similar to the address book application).
 # Import the delete.png and delete_selected.png files into the project's resources folder.
 # Create a new subclass of NSObject, called `DeleteRowController.m`
 # Add the following code to the `DeleteRowController.h` file.  _NOTE: The requirement of a delegate property will be removed in a future version of the library._
{{{
#import "CDLTableRowController.h"

@interface DeleteRowController : NSObject <CDLTableRowControllerProtocol> {
	id<CDLTableRowControllerDelegate>				_delegate;
	BOOL											_inAddMode;

}

/** Initialize the RowController with the given dictionary */
- (id) initForDictionary:(NSDictionary *) rowInformation;

/** Provide a UITableViewCell for this row. */
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath;

/** Provide action if the UITableViewCell for this row is selected. */
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;

/** Currently unexposed property to know if the row is in add mode */
@property (nonatomic, assign, setter=setInAddMode) BOOL inAddMode;

@end
}}}
 # Now, lets implement the methods in `DeleteRowController.m`.  Some implementation notes:
  * We do not need to worry reading information from  the row dictionary during initialization; other custom row controllers might need to save this information.  Note that any key/value combination you define in the property list file under this row would be available in the row dictionary passed upon initialization. 
  * We exposed the inAddMode property in the header file.  This property is set to true when the detailView is presented as part of adding a new object. This will be exposed in the TableRowControllerProtocol in a future version.  We make use of this property to hide the Delete button in add mode.
{{{
#import "DeleteRowController.h"
#import "DataController.h"

@implementation DeleteRowController

@synthesize delegate = _delegate;
@synthesize inAddMode = _inAddMode;

/** Initialize the RowController with the given dictionary */
- (id) initForDictionary:(NSDictionary *) rowInformation
{
	//do nothing
	return [super init];
}

/** Provide a UITableViewCell for this row. */
- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath
{
	static NSString *CellIdentifierDeleteCell = @"DeleteCell";
	
	UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifierDeleteCell];
	UIImageView *backgroundView;
	UIImageView *selectedBackgroundView;
	
	if (cell == nil) {
		cell = [[[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:CellIdentifierDeleteCell] autorelease];
		backgroundView = [[[UIImageView alloc] initWithFrame:CGRectZero] autorelease];
		selectedBackgroundView = [[[UIImageView alloc] initWithFrame:CGRectZero] autorelease];
		selectedBackgroundView.tag = 1002;
		backgroundView.tag = 1001;
		
		cell.backgroundView = backgroundView;
		cell.selectedBackgroundView = selectedBackgroundView;
		
		cell.textLabel.backgroundColor = [UIColor clearColor];
		cell.textLabel.textAlignment = UITextAlignmentCenter;
		cell.textLabel.font = [UIFont boldSystemFontOfSize:18.0];
	} else {
		backgroundView = (UIImageView *)[cell viewWithTag:1001];
		selectedBackgroundView = (UIImageView *)[cell viewWithTag:1002];
	}
	
	if (!self.inAddMode) {
		backgroundView.image = [UIImage imageNamed:@"delete.png"];
		selectedBackgroundView.image = [UIImage imageNamed:@"delete_selected.png"];
		cell.textLabel.text = @"Delete Event"; //could be made generic by getting the rowLabel from the rowDictionary upon init.
		cell.textLabel.textColor = [UIColor whiteColor];
	} else {
		//hide the cell in add mode
		
		backgroundView.image = nil;
		selectedBackgroundView.image = nil;
		cell.textLabel.text = nil;
		cell.textLabel.textColor = [UIColor whiteColor];
	}


	

	return cell;
}

/** Provide action if the UITableViewCell for this row is selected. */
- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
	//future implementations could include a confirmation action sheet
	
	//based on the knowledge we have about CDL - DetailView is a UITableViewController subclass
	id navController = [(UITableViewController *)[tableView delegate] navigationController];
	
	[navController popViewControllerAnimated:YES];
	
	[MANAGED_OBJECT_CONTEXT deleteObject:[self.delegate managedObject]];
}

- (NSIndexPath *)tableView:(UITableView *)tableView willSelectRowAtIndexPath:(NSIndexPath *)indexPath
{
	//override to allow selection during non-editing mode
	if (!self.inAddMode) { 
		return indexPath;
	} else { //don't allow selection of hidden cell during add mode
		return nil;
	}
		
}





@end
}}}